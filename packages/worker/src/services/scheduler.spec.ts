import { describe, it, beforeEach, afterEach } from "node:test";
import assert from "node:assert";
import { TaskScheduler } from "./scheduler.ts";
import type { ProductManager } from "@isomorphiq/profiles";

// Mock ProductManager for testing
/**
 * TODO: Reimplement this class using @tsimpl/core and @tsimpl/runtime's struct/trait/impl pattern inspired by Rust.
 */
class MockProductManager implements Partial<ProductManager> {
	private tasks: any[] = [];
	
	async createTask(
		title: string,
		description: string,
		priority: "high" | "medium" | "low",
		dependencies: string[] = [],
		createdBy?: string,
		assignedTo?: string,
		collaborators?: string[],
		watchers?: string[],
		type?: string
	) {
		const task = {
			id: `task_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
			title,
			description,
			priority,
			dependencies,
			createdBy,
			assignedTo,
			collaborators,
			watchers,
			type,
			status: "todo",
			createdAt: new Date().toISOString(),
			updatedAt: new Date().toISOString()
		};
		this.tasks.push(task);
		return task;
	}
	
	async getAllTasks() {
		return this.tasks;
	}
	
	setWebSocketManager(_wsManager: any) {
		// Mock implementation
	}
}

describe("TaskScheduler", () => {
    let scheduler: TaskScheduler;
    let mockProductManager: MockProductManager;
    let originalConsoleLog: typeof console.log;

    beforeEach(() => {
        originalConsoleLog = console.log;
        console.log = () => {};

        mockProductManager = new MockProductManager() as ProductManager;
        scheduler = new TaskScheduler(mockProductManager);
    });
    
    afterEach(async () => {
        await scheduler.shutdown();
        console.log = originalConsoleLog;
    });

	describe("Initialization", () => {
		it("should initialize successfully", async () => {
			await scheduler.initialize();
			assert.strictEqual(true, true); // If we reach here, initialization succeeded
		});
	});

	describe("Scheduled Task Creation", () => {
		it("should create a scheduled task with valid data", async () => {
			await scheduler.initialize();
			
			const scheduleData = {
				name: "Test Scheduled Task",
				description: "A test task for scheduling",
				cronExpression: "0 0 * * *", // Daily at midnight
				isActive: true,
				taskTemplate: {
					title: "Generated Test Task",
					description: "This task was generated by scheduler",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			};
			
			const scheduledTask = await scheduler.createScheduledTask(scheduleData);
			
			assert.strictEqual(scheduledTask.name, scheduleData.name);
			assert.strictEqual(scheduledTask.description, scheduleData.description);
			assert.strictEqual(scheduledTask.cronExpression, scheduleData.cronExpression);
			assert.strictEqual(scheduledTask.isActive, scheduleData.isActive);
			assert.strictEqual(scheduledTask.taskTemplate.title, scheduleData.taskTemplate.title);
			assert.strictEqual(scheduledTask.runCount, 0);
			assert.strictEqual(scheduledTask.failureCount, 0);
			assert.ok(scheduledTask.id);
			assert.ok(scheduledTask.createdAt);
			assert.ok(scheduledTask.updatedAt);
		});

		it("should reject scheduled task with invalid cron expression", async () => {
			await scheduler.initialize();
			
			const scheduleData = {
				name: "Invalid Cron Task",
				description: "A task with invalid cron",
				cronExpression: "invalid-cron",
				isActive: true,
				taskTemplate: {
					title: "Invalid Task",
					description: "This should fail",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			};
			
			await assert.rejects(
				async () => scheduler.createScheduledTask(scheduleData),
				/Error: Invalid cron expression/
			);
		});

		it("should create scheduled task with timezone", async () => {
			await scheduler.initialize();
			
			const scheduleData = {
				name: "Timezone Task",
				description: "A task with timezone",
				cronExpression: "0 12 * * *", // Daily at noon
				timezone: "America/New_York",
				isActive: true,
				taskTemplate: {
					title: "Timezone Task",
					description: "Task with timezone support",
					priority: "low" as const,
					createdBy: "test-user"
				}
			};
			
			const scheduledTask = await scheduler.createScheduledTask(scheduleData);
			assert.strictEqual(scheduledTask.timezone, scheduleData.timezone);
		});
	});

	describe("Scheduled Task Retrieval", () => {
		it("should retrieve all scheduled tasks", async () => {
			await scheduler.initialize();
			
			// Create multiple tasks
			await scheduler.createScheduledTask({
				name: "Task 1",
				description: "First task",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Task 1",
					description: "First task",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			});
			
			await scheduler.createScheduledTask({
				name: "Task 2",
				description: "Second task",
				cronExpression: "0 1 * * *",
				isActive: false,
				taskTemplate: {
					title: "Task 2",
					description: "Second task",
					priority: "high" as const,
					createdBy: "test-user"
				}
			});
			
			const allTasks = scheduler.getAllScheduledTasks();
			assert.strictEqual(allTasks.length, 2);
		});

		it("should retrieve active scheduled tasks only", async () => {
			await scheduler.initialize();
			
			// Create active and inactive tasks
			await scheduler.createScheduledTask({
				name: "Active Task",
				description: "Active task",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Active Task",
					description: "Active task",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			});
			
			await scheduler.createScheduledTask({
				name: "Inactive Task",
				description: "Inactive task",
				cronExpression: "0 1 * * *",
				isActive: false,
				taskTemplate: {
					title: "Inactive Task",
					description: "Inactive task",
					priority: "high" as const,
					createdBy: "test-user"
				}
			});
			
			const activeTasks = scheduler.getActiveScheduledTasks();
			assert.strictEqual(activeTasks.length, 1);
			assert.strictEqual(activeTasks[0].name, "Active Task");
		});

		it("should retrieve specific scheduled task by ID", async () => {
			await scheduler.initialize();
			
			const task = await scheduler.createScheduledTask({
				name: "Specific Task",
				description: "Task to find",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Specific Task",
					description: "Task to find",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			});
			
			const foundTask = scheduler.getScheduledTask(task.id);
			assert.ok(foundTask);
			assert.strictEqual(foundTask!.id, task.id);
			assert.strictEqual(foundTask!.name, task.name);
		});

		it("should return null for non-existent task ID", async () => {
			await scheduler.initialize();
			
			const foundTask = scheduler.getScheduledTask("non-existent-id");
			assert.strictEqual(foundTask, null);
		});
	});

	describe("Scheduled Task Updates", () => {
		it("should update scheduled task properties", async () => {
			await scheduler.initialize();
			
			const task = await scheduler.createScheduledTask({
				name: "Original Task",
				description: "Original description",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Original Title",
					description: "Original task description",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			});
			
			const updates = {
				name: "Updated Task",
				description: "Updated description",
				isActive: false,
				taskTemplate: {
					...task.taskTemplate,
					title: "Updated Title",
					priority: "high" as const
				}
			};
			
			const updatedTask = await scheduler.updateScheduledTask(task.id, updates);
			
			assert.strictEqual(updatedTask.name, updates.name);
			assert.strictEqual(updatedTask.description, updates.description);
			assert.strictEqual(updatedTask.isActive, updates.isActive);
			assert.strictEqual(updatedTask.taskTemplate.title, updates.taskTemplate.title);
			assert.strictEqual(updatedTask.taskTemplate.priority, updates.taskTemplate.priority);
			assert.ok(updatedTask.updatedAt > task.updatedAt);
		});

		it("should reject update for non-existent task", async () => {
			await scheduler.initialize();
			
			await assert.rejects(
				async () => scheduler.updateScheduledTask("non-existent-id", { name: "Updated" }),
				/Scheduled task not found: non-existent-id/
			);
		});
	});

	describe("Scheduled Task Deletion", () => {
		it("should delete scheduled task", async () => {
			await scheduler.initialize();
			
			const task = await scheduler.createScheduledTask({
				name: "Task to Delete",
				description: "This task will be deleted",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Task to Delete",
					description: "This task will be deleted",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			});
			
			const deleted = await scheduler.deleteScheduledTask(task.id);
			assert.strictEqual(deleted, true);
			
			const foundTask = scheduler.getScheduledTask(task.id);
			assert.strictEqual(foundTask, null);
		});

		it("should return false for non-existent task deletion", async () => {
			await scheduler.initialize();
			
			const deleted = await scheduler.deleteScheduledTask("non-existent-id");
			assert.strictEqual(deleted, false);
		});
	});

	describe("Cron Expression Validation", () => {
		it("should validate valid cron expressions", async () => {
			await scheduler.initialize();
			
			const validExpressions = [
				"0 0 * * *", // Daily at midnight
				"0 9 * * 1-5", // Weekdays at 9 AM
				"*/15 * * * *", // Every 15 minutes
				"0 0 1 * *", // Monthly on 1st
				"0 0 * * 0" // Weekly on Sunday
			];
			
			for (const expression of validExpressions) {
				const validation = scheduler.validateCronExpression(expression);
				assert.strictEqual(validation.isValid, true, `Expression should be valid: ${expression}`);
				assert.strictEqual(validation.errors.length, 0, `Should have no errors: ${expression}`);
			}
		});

		it("should reject invalid cron expressions", async () => {
			await scheduler.initialize();
			
			const invalidExpressions = [
				"invalid-cron",
				"60 0 * * *", // Invalid minute
				"0 25 * * *", // Invalid hour
				"0 0 32 * *", // Invalid day
				"abc def * * *" // Invalid format
			];
			
			for (const expression of invalidExpressions) {
				const validation = scheduler.validateCronExpression(expression);
				assert.strictEqual(validation.isValid, false, `Expression should be invalid: ${expression}`);
				assert.ok(validation.errors.length > 0, `Should have errors: ${expression}`);
			}
		});

		it("should provide warnings for potentially problematic expressions", async () => {
			await scheduler.initialize();
			
			// Test every minute warning
			const validation1 = scheduler.validateCronExpression("* * * * *");
			assert.strictEqual(validation1.isValid, true);
			assert.ok(validation1.warnings.some(w => w.includes("every minute")));
			
			// Test daily midnight warning
			const validation2 = scheduler.validateCronExpression("0 0 * * *");
			assert.strictEqual(validation2.isValid, true);
			assert.ok(validation2.warnings.some(w => w.includes("daily at midnight")));
		});
	});

	describe("Scheduler Statistics", () => {
		it("should provide accurate statistics", async () => {
			await scheduler.initialize();
			
			// Create tasks with different statuses
			await scheduler.createScheduledTask({
				name: "Active Task 1",
				description: "Active task",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Active Task 1",
					description: "Active task",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			});
			
			await scheduler.createScheduledTask({
				name: "Active Task 2",
				description: "Another active task",
				cronExpression: "0 1 * * *",
				isActive: true,
				taskTemplate: {
					title: "Active Task 2",
					description: "Another active task",
					priority: "high" as const,
					createdBy: "test-user"
				}
			});
			
			await scheduler.createScheduledTask({
				name: "Inactive Task",
				description: "Inactive task",
				cronExpression: "0 2 * * *",
				isActive: false,
				taskTemplate: {
					title: "Inactive Task",
					description: "Inactive task",
					priority: "low" as const,
					createdBy: "test-user"
				}
			});
			
			const stats = scheduler.getStats();
			
			assert.strictEqual(stats.totalSchedules, 3);
			assert.strictEqual(stats.activeSchedules, 2);
			assert.strictEqual(stats.inactiveSchedules, 1);
			assert.strictEqual(stats.totalRuns, 0); // No runs yet
			assert.strictEqual(stats.failedRuns, 0);
			assert.strictEqual(stats.successRate, 100); // 100% when no failures
		});
	});

	describe("Task Execution", () => {
		it("should interpolate variables in task template", async () => {
			await scheduler.initialize();
			
			const scheduleData = {
				name: "Variable Task",
				description: "Task with variables",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Task for {{DATE}}",
					description: "Created on {{DATETIME}} (Timestamp: {{TIMESTAMP}})",
					priority: "medium" as const,
					createdBy: "test-user",
					variables: {
						CUSTOM_VAR: "custom-value"
					}
				}
			};
			
			const task = await scheduler.createScheduledTask(scheduleData);
			
			// Check that variables would be interpolated (actual execution happens via cron)
			assert.ok(task.taskTemplate.title.includes("{{DATE}}"));
			assert.ok(task.taskTemplate.description.includes("{{DATETIME}}"));
			assert.ok(task.taskTemplate.description.includes("{{TIMESTAMP}}"));
		});
	});

	describe("Scheduler Control", () => {
		it("should pause and resume scheduler", async () => {
			await scheduler.initialize();
			
			// Should be running initially
			assert.doesNotThrow(() => scheduler.pause());
			assert.doesNotThrow(() => scheduler.resume());
		});
	});

	describe("Dependency Management", () => {
		it("should validate scheduled task dependencies", async () => {
			await scheduler.initialize();
			
			// Create a regular task first to serve as dependency
			const dependencyTask = await mockProductManager.createTask(
				"Dependency Task",
				"Task that serves as dependency",
				"medium",
				[],
				"test-user"
			);
			
			const scheduledTask = await scheduler.createScheduledTask({
				name: "Dependent Task",
				description: "Task with dependencies",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Dependent Task",
					description: "Task with dependencies",
					priority: "medium" as const,
					createdBy: "test-user",
					dependencies: [dependencyTask.id]
				}
			});
			
			const validation = await scheduler.validateScheduledTaskDependencies(scheduledTask.id);
			assert.strictEqual(validation.isValid, true);
			assert.strictEqual(validation.readyToExecute, false); // Dependency not done yet
			assert.strictEqual(validation.missingDependencies.length, 0);
		});

		it("should detect missing dependencies", async () => {
			await scheduler.initialize();
			
			const scheduledTask = await scheduler.createScheduledTask({
				name: "Task with Missing Dep",
				description: "Task with non-existent dependency",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Task with Missing Dep",
					description: "Task with non-existent dependency",
					priority: "medium" as const,
					createdBy: "test-user",
					dependencies: ["non-existent-task-id"]
				}
			});
			
			const validation = await scheduler.validateScheduledTaskDependencies(scheduledTask.id);
			assert.strictEqual(validation.isValid, false);
			assert.strictEqual(validation.readyToExecute, false);
			assert.ok(validation.missingDependencies.includes("non-existent-task-id"));
		});
	});

	describe("Error Handling", () => {
		it("should handle task creation failure gracefully", async () => {
			await scheduler.initialize();
			
			// Test with missing required fields
			const invalidData = {
				name: "",
				description: "Task with no name",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "",
					description: "Task with empty title",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			};
			
			// Should not throw, but may create task with empty fields
			const task = await scheduler.createScheduledTask(invalidData);
			assert.ok(task); // Should still create task
		});
	});
});
