import { describe, it, beforeEach, afterEach } from "node:test";
import assert from "node:assert";
import * as cron from "node-cron";
import { TaskScheduler } from "./scheduler.ts";
import type { ProductManager } from "@isomorphiq/tasks";

// Mock ProductManager for integration testing
class IntegrationTestProductManager implements ProductManager {
	private tasks: any[] = [];
	
	async initialize(): Promise<void> {
		// Mock initialization
	}

	async createTask(
		title: string,
		description: string,
		priority: "high" | "medium" | "low" = "medium",
		dependencies: string[] = [],
		createdBy?: string,
		assignedTo?: string,
		collaborators?: string[],
		watchers?: string[],
		type: "feature" | "story" | "task" | "integration" | "research" = "task"
	) {
		const task = {
			id: `task_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
			title,
			description,
			priority,
			dependencies,
			createdBy,
			assignedTo,
			collaborators,
			watchers,
			type,
			status: "todo" as const,
			createdAt: new Date(),
			updatedAt: new Date()
		};
		this.tasks.push(task);
		return task;
	}

	async getAllTasks() {
		return this.tasks;
	}

	// Minimal ProductManager implementation for testing
	get taskService() { return this; }
	get templateManager() { return this; }
	get automationEngine() { return this; }
	get db() { return this; }
	// Add other required methods as no-ops
	async updateTaskStatus() { return {} as any; }
	async updateTaskPriority() { return {} as any; }
	async deleteTask() { return; }
	getWebSocketManager() { return {} as any; }
	setWebSocketManager() { return; }
	getTask() { return null; }
	getTasksByFilter() { return []; }
	getTasksByPriority() { return []; }
	getTasksByStatus() { return []; }
	getTasksByAssignee() { return []; }
	getTasksByCreator() { return []; }
	searchTasks() { return []; }
	getTaskMetrics() { return {} as any; }
	getProfileStates() { return new Map(); }
	getProfileState() { return null; }
	getProfileMetrics() { return new Map(); }
	getAllProfileMetrics() { return new Map(); }
	getProfilesWithStates() { return []; }
	getProfileTaskQueue() { return []; }
	updateProfileStatus() { return {} as any; }
	getBestProfileForTask() { return null; }
	assignTaskToProfile() { return {} as any; }
	processTasksLoop() { return Promise.resolve(); }
}

describe("TaskScheduler Integration Tests", () => {
	let scheduler: TaskScheduler;
	let productManager: IntegrationTestProductManager;
	
	beforeEach(() => {
		productManager = new IntegrationTestProductManager();
		scheduler = new TaskScheduler(productManager);
	});
	
	afterEach(async () => {
		await scheduler.shutdown();
	});

	describe("Cron Execution Integration", () => {
		it("should create cron jobs for active scheduled tasks", async () => {
			await scheduler.initialize();
			
			const scheduleData = {
				name: "Cron Test Task",
				description: "Test cron job creation",
				cronExpression: "*/1 * * * *", // Every minute for testing
				isActive: true,
				taskTemplate: {
					title: "Cron Generated Task",
					description: "Task generated by cron",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			};
			
			const scheduledTask = await scheduler.createScheduledTask(scheduleData);
			
			// Verify task was created
			assert.ok(scheduledTask.id);
			assert.strictEqual(scheduledTask.name, scheduleData.name);
			assert.strictEqual(scheduledTask.isActive, true);
			
			// Verify the task is in the scheduler's list
			const retrievedTask = scheduler.getScheduledTask(scheduledTask.id);
			assert.ok(retrievedTask);
			assert.strictEqual(retrievedTask!.id, scheduledTask.id);
		});

		it("should handle timezone-aware scheduling", async () => {
			await scheduler.initialize();
			
			const scheduleData = {
				name: "Timezone Test",
				description: "Test timezone handling",
				cronExpression: "0 12 * * *", // Daily at noon
				timezone: "UTC",
				isActive: true,
				taskTemplate: {
					title: "Timezone Task",
					description: "Task with timezone",
					priority: "low" as const,
					createdBy: "test-user"
				}
			};
			
			const scheduledTask = await scheduler.createScheduledTask(scheduleData);
			assert.strictEqual(scheduledTask.timezone, "UTC");
			
			// Verify timezone is preserved when updating
			const updated = await scheduler.updateScheduledTask(scheduledTask.id, {
				timezone: "America/New_York"
			});
			assert.strictEqual(updated.timezone, "America/New_York");
		});

		it("should validate cron expressions during task creation", async () => {
			await scheduler.initialize();
			
			const invalidExpressions = [
				"invalid-cron",
				"60 * * * *", // Invalid minute
				"* 25 * * *", // Invalid hour
				"* * 32 * *", // Invalid day
				"* * * 13 *", // Invalid month
				"* * * * 8"   // Invalid day of week
			];
			
			for (const expression of invalidExpressions) {
				try {
					await scheduler.createScheduledTask({
						name: "Invalid Cron Test",
						description: "Should fail",
						cronExpression: expression,
						isActive: true,
						taskTemplate: {
							title: "Should Fail",
							description: "Task with invalid cron",
							priority: "medium" as const,
							createdBy: "test-user"
						}
					});
					assert.fail(`Should have rejected invalid cron expression: ${expression}`);
				} catch (error) {
					assert.ok(error instanceof Error);
					assert.ok(error.message.includes("Invalid cron expression") || 
								error.message.includes("cron expression"));
				}
			}
		});

		it("should manage task lifecycle (create, update, delete)", async () => {
			await scheduler.initialize();
			
			// Create
			const createdTask = await scheduler.createScheduledTask({
				name: "Lifecycle Test",
				description: "Test full lifecycle",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Lifecycle Task",
					description: "Full lifecycle test",
					priority: "high" as const,
					createdBy: "test-user"
				}
			});
			
			// Update
			const updatedTask = await scheduler.updateScheduledTask(createdTask.id, {
				name: "Updated Lifecycle Test",
				isActive: false,
				taskTemplate: {
					...createdTask.taskTemplate,
					priority: "low" as const
				}
			});
			
			assert.strictEqual(updatedTask.name, "Updated Lifecycle Test");
			assert.strictEqual(updatedTask.isActive, false);
			assert.strictEqual(updatedTask.taskTemplate.priority, "low");
			assert.ok(updatedTask.updatedAt > createdTask.updatedAt);
			
			// Delete
			const deleted = await scheduler.deleteScheduledTask(createdTask.id);
			assert.strictEqual(deleted, true);
			
			const retrievedTask = scheduler.getScheduledTask(createdTask.id);
			assert.strictEqual(retrievedTask, null);
		});
	});

	describe("Variable Interpolation Integration", () => {
		it("should interpolate built-in variables correctly", async () => {
			await scheduler.initialize();
			
			const scheduleData = {
				name: "Variable Test",
				description: "Test variable interpolation",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Task for {{DATE}}",
					description: "Created at {{DATETIME}} ({{TIMESTAMP}})",
					priority: "medium" as const,
					createdBy: "test-user",
					variables: {
						CUSTOM_VAR: "test-value",
						NUMBER_VAR: "42"
					}
				}
			};
			
			const scheduledTask = await scheduler.createScheduledTask(scheduleData);
			
			// Check that the task template contains the placeholders
			assert.ok(scheduledTask.taskTemplate.title.includes("{{DATE}}"));
			assert.ok(scheduledTask.taskTemplate.description.includes("{{DATETIME}}"));
			assert.ok(scheduledTask.taskTemplate.description.includes("{{TIMESTAMP}}"));
		});

		it("should handle custom variables", async () => {
			await scheduler.initialize();
			
			const scheduleData = {
				name: "Custom Variable Test",
				description: "Test custom variables",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Custom: {{CUSTOM_VAR}}",
					description: "Number: {{NUMBER_VAR}}",
					priority: "medium" as const,
					createdBy: "test-user",
					variables: {
						CUSTOM_VAR: "custom-value",
						NUMBER_VAR: "123",
						TEXT_VAR: "some text"
					}
				}
			};
			
			const scheduledTask = await scheduler.createScheduledTask(scheduleData);
			assert.strictEqual(scheduledTask.taskTemplate.variables?.CUSTOM_VAR, "custom-value");
			assert.strictEqual(scheduledTask.taskTemplate.variables?.NUMBER_VAR, "123");
			assert.strictEqual(scheduledTask.taskTemplate.variables?.TEXT_VAR, "some text");
		});
	});

	describe("Error Handling Integration", () => {
		it("should handle scheduler initialization failure gracefully", async () => {
			// Test with null product manager
			try {
				const invalidScheduler = new TaskScheduler(null as any);
				await invalidScheduler.initialize();
				// Should not crash
				assert.ok(true);
			} catch (error) {
				// Should handle gracefully
				assert.ok(error instanceof Error);
			}
		});

		it("should handle concurrent operations", async () => {
			await scheduler.initialize();
			
			// Create multiple tasks concurrently
			const createPromises = Array.from({ length: 5 }, (_, i) => 
				scheduler.createScheduledTask({
					name: `Concurrent Task ${i}`,
					description: `Task ${i} created concurrently`,
					cronExpression: `0 ${i} * * *`,
					isActive: true,
					taskTemplate: {
						title: `Concurrent Task ${i}`,
						description: `Concurrent task ${i}`,
						priority: "medium" as const,
						createdBy: "test-user"
					}
				})
			);
			
			const tasks = await Promise.all(createPromises);
			assert.strictEqual(tasks.length, 5);
			
			// Verify all tasks have unique IDs
			const ids = tasks.map(t => t.id);
			const uniqueIds = new Set(ids);
			assert.strictEqual(uniqueIds.size, 5);
		});
	});

	describe("Statistics Integration", () => {
		it("should provide comprehensive statistics", async () => {
			await scheduler.initialize();
			
			// Create tasks with different configurations
			await scheduler.createScheduledTask({
				name: "Active Task 1",
				description: "First active task",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Active Task 1",
					description: "First active task",
					priority: "high" as const,
					createdBy: "test-user"
				}
			});
			
			await scheduler.createScheduledTask({
				name: "Active Task 2",
				description: "Second active task",
				cronExpression: "0 1 * * *",
				isActive: true,
				taskTemplate: {
					title: "Active Task 2",
					description: "Second active task",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			});
			
			await scheduler.createScheduledTask({
				name: "Inactive Task",
				description: "Inactive task",
				cronExpression: "0 2 * * *",
				isActive: false,
				taskTemplate: {
					title: "Inactive Task",
					description: "Inactive task",
					priority: "low" as const,
					createdBy: "test-user"
				}
			});
			
			const stats = scheduler.getStats();
			
			assert.strictEqual(stats.totalSchedules, 3);
			assert.strictEqual(stats.activeSchedules, 2);
			assert.strictEqual(stats.inactiveSchedules, 1);
			assert.strictEqual(stats.totalRuns, 0); // No executions yet
			assert.strictEqual(stats.failedRuns, 0);
			assert.strictEqual(stats.successRate, 100); // 100% when no failures
		});
	});

	describe("Pause/Resume Integration", () => {
		it("should pause and resume scheduler operations", async () => {
			await scheduler.initialize();
			
			// Create a task
			const task = await scheduler.createScheduledTask({
				name: "Pause Test Task",
				description: "Test pause/resume",
				cronExpression: "*/1 * * * *",
				isActive: true,
				taskTemplate: {
					title: "Pause Test",
					description: "Pause/resume test",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			});
			
			// Should work normally initially
			assert.strictEqual(task.isActive, true);
			
			// Pause scheduler
			scheduler.pause();
			
			// Resume scheduler
			scheduler.resume();
			
			// Task should still be active after resume
			const retrievedTask = scheduler.getScheduledTask(task.id);
			assert.ok(retrievedTask);
			assert.strictEqual(retrievedTask!.isActive, true);
		});
	});

	describe("Dependency-Aware Scheduling", () => {
		it("should validate task dependencies", async () => {
			await scheduler.initialize();
			
			// Create a regular task first
			const dependencyTask = await productManager.createTask(
				"Dependency Task",
				"Task that serves as dependency",
				"medium",
				[],
				"test-user"
			);
			
			const scheduledTask = await scheduler.createScheduledTask({
				name: "Dependent Scheduled Task",
				description: "Scheduled task with dependencies",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Dependent Task",
					description: "Task with dependencies",
					priority: "medium" as const,
					createdBy: "test-user",
					dependencies: [dependencyTask.id]
				}
			});
			
			const validation = await scheduler.validateScheduledTaskDependencies(scheduledTask.id);
			assert.ok(validation);
			assert.ok(typeof validation.isValid === "boolean");
			assert.ok(typeof validation.readyToExecute === "boolean");
			assert.ok(Array.isArray(validation.missingDependencies));
			assert.ok(Array.isArray(validation.circularDependencies));
		});

		it("should provide scheduling recommendations", async () => {
			await scheduler.initialize();
			
			// Create tasks with different dependency patterns
			await scheduler.createScheduledTask({
				name: "Independent Task",
				description: "No dependencies",
				cronExpression: "0 0 * * *",
				isActive: true,
				taskTemplate: {
					title: "Independent Task",
					description: "No dependencies",
					priority: "medium" as const,
					createdBy: "test-user"
				}
			});
			
			await scheduler.createScheduledTask({
				name: "Dependent Task",
				description: "Has dependencies",
				cronExpression: "0 1 * * *",
				isActive: true,
				taskTemplate: {
					title: "Dependent Task",
					description: "Has dependencies",
					priority: "medium" as const,
					createdBy: "test-user",
					dependencies: ["some-dependency-id"]
				}
			});
			
			const recommendations = scheduler.getDependencySchedulingRecommendations();
			assert.ok(Array.isArray(recommendations));
			assert.ok(recommendations.length >= 2);
			
			// Should have recommendations for both tasks
			const independentRec = recommendations.find(r => r.taskName === "Independent Task");
			const dependentRec = recommendations.find(r => r.taskName === "Dependent Task");
			
			assert.ok(independentRec);
			assert.ok(dependentRec);
			
			assert.strictEqual(independentRec!.recommendation, "proceed");
			assert.ok(dependentRec!.recommendation !== "proceed"); // Should have some issue
		});
	});
});